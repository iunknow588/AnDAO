# 智能合约账户创建流程详解

## 文档信息
- **项目名称**: AnDaoWallet Smart Services
- **版本**: 3.0.0
- **文档创建日期**: 2025-01-13
- **适用合约**: Kernel (ERC-4337 兼容的智能合约账户)

---

## 1. 概述

智能合约账户的创建采用 **工厂模式（Factory Pattern）** 和 **代理模式（Proxy Pattern）**，通过 `KernelFactory` 合约使用 CREATE2 确定性地址部署账户实例。整个流程包括地址预测、合约部署、账户初始化等步骤。

---

## 2. 创建流程总览

```
用户请求创建账户
    ↓
1. 预测账户地址（可选，用于检查是否已存在）
    ↓
2. 构造初始化数据（initData）
    ↓
3. 生成盐值（salt）
    ↓
4. 调用 KernelFactory.createAccount()
    ↓
5. Factory 使用 CREATE2 部署代理合约
    ↓
6. 调用账户的 initialize() 方法
    ↓
7. 初始化验证器（Validator）
    ↓
8. 返回账户地址
```

---

## 3. 详细流程步骤

### 3.1 前置准备

在创建账户之前，需要确保以下合约已部署：

- **Kernel 实现合约** (`implementation`): 账户逻辑实现
- **KernelFactory**: 账户工厂合约
- **EntryPoint**: ERC-4337 EntryPoint 合约
- **验证器合约**: 如 `MultiChainValidator` 或 `ECDSAValidator`

### 3.2 步骤 1: 预测账户地址（可选）

**目的**: 在部署前预测账户地址，可以：
- 检查账户是否已存在
- 提前准备资金
- 优化用户体验

**实现位置**: `src/services/AccountManager.ts` - `predictAccountAddress()`

**代码逻辑**:
```typescript
async predictAccountAddress(owner: Address, chainId: number): Promise<Address> {
  // 1. 构造初始化数据
  const initData = await this.buildInitData(owner, chainId);
  
  // 2. 生成盐值
  const salt = await this.generateSalt(owner, chainId);
  
  // 3. 调用 Factory 的 getAddress 方法预测地址
  return await predictAccountAddress(
    factoryAddress,
    initData,
    salt,
    rpcUrl
  );
}
```

**合约方法**: `KernelFactory.getAddress(bytes calldata data, bytes32 salt)`

**地址计算原理**:
```solidity
function getAddress(bytes calldata data, bytes32 salt) 
    public view virtual returns (address) {
    bytes32 actualSalt = keccak256(abi.encodePacked(data, salt));
    return LibClone.predictDeterministicAddressERC1967(
        implementation, 
        actualSalt, 
        address(this)
    );
}
```

**地址确定性保证**:
- 使用 CREATE2 确定性地址生成
- 相同的 `data` 和 `salt` 总是生成相同的地址
- 即使账户未部署，地址也是可预测的

---

### 3.3 步骤 2: 构造初始化数据（initData）

**目的**: 编码 `Kernel.initialize()` 方法的调用数据

**实现位置**: `src/services/AccountManager.ts` - `buildInitData()`

**初始化数据结构**:
```solidity
function initialize(
    ValidationId _rootValidator,  // 根验证器 ID (bytes21)
    IHook hook,                   // 钩子合约地址
    bytes calldata validatorData, // 验证器初始化数据
    bytes calldata hookData,      // 钩子初始化数据
    bytes[] calldata initConfig   // 额外配置数据
) external
```

**构造过程**:

#### 3.3.1 构造 ValidationId

ValidationId 是 `bytes21` 类型，格式为：
- 第 1 字节：验证器类型（`MODULE_TYPE_VALIDATOR = 1`）
- 后 20 字节：验证器合约地址

```typescript
const validatorType = 1; // MODULE_TYPE_VALIDATOR
const validationId = `0x${validatorType.toString(16).padStart(2, '0')}${validatorAddress.slice(2)}`.slice(0, 44);
// 结果: 0x01 + 20字节地址 = 21字节 = 42 hex字符 + 0x前缀
```

#### 3.3.2 构造 validatorData

对于 `MultiChainValidator`，`validatorData` 是所有者地址（20 字节）：

```typescript
const validatorData = owner.slice(0, 42) as `0x${string}`; // owner 地址
```

对于 `ECDSAValidator`，格式相同：
```solidity
// ECDSAValidator.onInstall() 接收 owner 地址
function onInstall(bytes calldata _data) external payable override {
    address owner = address(bytes20(_data[0:20]));
    ecdsaValidatorStorage[msg.sender].owner = owner;
    emit OwnerRegistered(msg.sender, owner);
}
```

#### 3.3.3 构造 hookData

如果验证器也实现了 `IHook` 接口，可以传入钩子数据。通常初始化为空：

```typescript
const hookData = '0x' as `0x${string}`;
```

#### 3.3.4 构造 initConfig

额外的初始化配置，通常为空数组：

```typescript
const initConfig: `0x${string}`[] = [];
```

#### 3.3.5 编码函数调用

使用 `encodeFunctionData` 编码 `initialize` 函数调用：

```typescript
return encodeFunctionData({
  abi: [{
    inputs: [
      { name: '_rootValidator', type: 'bytes21' },
      { name: 'hook', type: 'address' },
      { name: 'validatorData', type: 'bytes' },
      { name: 'hookData', type: 'bytes' },
      { name: 'initConfig', type: 'bytes[]' },
    ],
    name: 'initialize',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  }],
  functionName: 'initialize',
  args: [validationId, validatorAddress, validatorData, hookData, initConfig],
});
```

---

### 3.4 步骤 3: 生成盐值（salt）

**目的**: 提供额外的随机性，确保不同用户/链生成不同的地址

**实现位置**: `src/services/AccountManager.ts` - `generateSalt()`

**生成逻辑**:
```typescript
private async generateSalt(owner: Address, chainId: number): Promise<`0x${string}`> {
  const encoder = new TextEncoder();
  const data = encoder.encode(`${owner}:${chainId}`);
  const hash = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hash));
  return `0x${hashArray.map(b => b.toString(16).padStart(2, '0')).join('')}`;
}
```

**特点**:
- 基于 `owner` 和 `chainId` 生成
- 使用 SHA-256 哈希确保确定性
- 相同输入总是生成相同盐值

---

### 3.5 步骤 4: 调用 Factory.createAccount()

**实现位置**: `src/utils/kernel.ts` - `createAccount()`

**调用流程**:
```typescript
export async function createAccount(
  factoryAddress: Address,
  initData: Hex,
  salt: Hex,
  rpcUrl: string,
  signerPrivateKey?: Hex
): Promise<Address> {
  if (signerPrivateKey) {
    // 使用签名者发送交易
    const account = privateKeyToAccount(signerPrivateKey);
    const walletClient = createWalletClient({
      account,
      transport: http(rpcUrl),
    });

    const hash = await walletClient.writeContract({
      address: factoryAddress,
      abi: KERNEL_FACTORY_ABI,
      functionName: 'createAccount',
      args: [initData, salt],
    });

    // 等待交易确认
    await publicClient.waitForTransactionReceipt({ hash });
    
    return predictAccountAddress(factoryAddress, initData, salt, rpcUrl);
  } else {
    // 仅预测地址，不实际创建
    return predictAccountAddress(factoryAddress, initData, salt, rpcUrl);
  }
}
```

**合约方法**: `KernelFactory.createAccount(bytes calldata data, bytes32 salt)`

---

### 3.6 步骤 5: Factory 部署代理合约

**合约位置**: `contracts/src/factory/KernelFactory.sol`

**部署逻辑**:
```solidity
function createAccount(bytes calldata data, bytes32 salt) 
    public payable returns (address) {
    // 1. 计算实际盐值
    bytes32 actualSalt = keccak256(abi.encodePacked(data, salt));
    
    // 2. 使用 CREATE2 部署代理合约
    (bool alreadyDeployed, address account) =
        LibClone.createDeterministicERC1967(
            msg.value,      // 可选的 ETH 转账
            implementation, // Kernel 实现合约地址
            actualSalt      // 盐值
        );
    
    // 3. 如果账户未部署，调用初始化
    if (!alreadyDeployed) {
        (bool success,) = account.call(data);
        if (!success) {
            revert InitializeError();
        }
    }
    
    return account;
}
```

**关键点**:
- 使用 `LibClone.createDeterministicERC1967` 创建 ERC-1967 代理
- 代理合约指向 `implementation` 地址
- 如果账户已存在（`alreadyDeployed = true`），跳过初始化
- 初始化失败会回滚整个交易

---

### 3.7 步骤 6: 账户初始化（initialize）

**合约位置**: `contracts/src/Kernel.sol` - `initialize()`

**初始化逻辑**:
```solidity
function initialize(
    ValidationId _rootValidator,
    IHook hook,
    bytes calldata validatorData,
    bytes calldata hookData,
    bytes[] calldata initConfig
) external {
    ValidationStorage storage vs = _validationStorage();
    
    // 1. 检查是否已初始化
    if (ValidationId.unwrap(vs.rootValidator) != bytes21(0) || 
        bytes3(address(this).code) == EIP7702_PREFIX) {
        revert AlreadyInitialized();
    }
    
    // 2. 验证 rootValidator 有效性
    if (ValidationId.unwrap(_rootValidator) == bytes21(0)) {
        revert InvalidValidator();
    }
    
    // 3. 验证验证器类型
    ValidationType vType = ValidatorLib.getType(_rootValidator);
    if (vType != VALIDATION_TYPE_VALIDATOR && 
        vType != VALIDATION_TYPE_PERMISSION) {
        revert InvalidValidationType();
    }
    
    // 4. 设置根验证器
    _setRootValidator(_rootValidator);
    
    // 5. 初始化验证配置
    ValidationConfig memory config = ValidationConfig({
        nonce: uint32(1),  // 初始 nonce 为 1
        hook: hook
    });
    vs.currentNonce = 1;
    
    // 6. 安装验证器
    _installValidation(_rootValidator, config, validatorData, hookData);
    
    // 7. 执行额外配置
    for (uint256 i = 0; i < initConfig.length; i++) {
        (bool success,) = address(this).call(initConfig[i]);
        if (!success) {
            revert InitConfigError(i);
        }
    }
}
```

**初始化检查**:
- 检查 `rootValidator` 是否已设置（防止重复初始化）
- 检查是否为 EIP-7702 账户（特殊处理）
- 验证验证器类型必须为 `VALIDATOR` 或 `PERMISSION`

**状态设置**:
- 设置根验证器 ID
- 初始化 nonce 为 1
- 配置验证器钩子

---

### 3.8 步骤 7: 安装验证器（_installValidation）

**内部方法**: `Kernel._installValidation()`

**安装流程**:
```solidity
function _installValidation(
    ValidationId vId,
    ValidationConfig memory config,
    bytes calldata validatorData,
    bytes calldata hookData
) internal {
    // 1. 获取验证器合约
    IValidator validator = ValidatorLib.getValidator(vId);
    
    // 2. 验证模块类型
    require(validator.isModuleType(MODULE_TYPE_VALIDATOR), "Invalid module type");
    
    // 3. 检查是否已初始化
    if (!validator.isInitialized(address(this))) {
        // 4. 调用验证器的 onInstall 方法
        validator.onInstall{value: msg.value}(validatorData);
    }
    
    // 5. 处理钩子
    if (address(config.hook) != address(0) && 
        address(config.hook) != HOOK_MODULE_NOT_INSTALLED) {
        if (!config.hook.isInitialized(address(this))) {
            config.hook.onInstall{value: msg.value}(hookData);
        }
    }
    
    // 6. 保存验证配置
    _validationStorage().validationConfig[vId] = config;
    
    // 7. 发出事件
    emit ValidatorInstalled(validator, config.nonce);
}
```

**验证器安装示例（ECDSAValidator）**:
```solidity
function onInstall(bytes calldata _data) external payable override {
    // 提取所有者地址（前20字节）
    address owner = address(bytes20(_data[0:20]));
    
    // 保存到存储
    ecdsaValidatorStorage[msg.sender].owner = owner;
    
    // 发出事件
    emit OwnerRegistered(msg.sender, owner);
}
```

**验证器安装示例（MultiChainValidator）**:
```solidity
function onInstall(bytes calldata _data) external payable override {
    address owner = address(bytes20(_data[0:20]));
    multiChainValidatorStorage[msg.sender].owner = owner;
    emit OwnerRegistered(msg.sender, owner);
}
```

---

### 3.9 步骤 8: 返回账户地址

**完成标志**:
- 代理合约已部署
- 账户已初始化
- 验证器已安装
- 交易已确认

**返回结果**:
```typescript
// 账户地址（与预测地址相同）
const accountAddress = await createAccount(...);

// 保存账户信息
const accountInfo: AccountInfo = {
  address: accountAddress,
  chainId,
  owner,
  createdAt: Date.now(),
  status: 'deployed',
  deployedAt: Date.now(),
};
```

---

## 4. 完整代码示例

### 4.1 前端调用示例

```typescript
// src/services/AccountManager.ts
async createAndDeployAccount(
  owner: Address, 
  chainId: number, 
  signerPrivateKey: `0x${string}`
): Promise<Address> {
  const chainConfig = getChainConfigByChainId(chainId);
  
  // 1. 预测地址（检查是否已存在）
  const predictedAddress = await this.predictAccountAddress(owner, chainId);
  const existing = await this.getAccount(owner, chainId);
  if (existing?.status === 'deployed') {
    const deployed = await this.accountExists(predictedAddress, chainId);
    if (deployed) {
      return predictedAddress;
    }
  }

  // 2. 构造初始化数据
  const initData = await this.buildInitData(owner, chainId);
  
  // 3. 生成盐值
  const salt = await this.generateSalt(owner, chainId);

  // 4. 部署账户
  const { createAccount } = await import('@/utils/kernel');
  const accountAddress = await createAccount(
    chainConfig.kernelFactoryAddress as Address,
    initData,
    salt,
    chainConfig.rpcUrl,
    signerPrivateKey
  );

  // 5. 保存账户信息
  const accountInfo: AccountInfo = {
    address: accountAddress,
    chainId,
    owner,
    createdAt: Date.now(),
    status: 'deployed',
    deployedAt: Date.now(),
  };

  this.accounts.set(this.getAccountKey(accountAddress, chainId), accountInfo);
  await this.saveAccounts();

  return accountAddress;
}
```

### 4.2 初始化数据构造示例

```typescript
// src/services/AccountManager.ts - buildInitData()
async buildInitData(owner: Address, chainId: number): Promise<`0x${string}`> {
  const chainConfig = getChainConfigByChainId(chainId);
  const multiChainValidatorAddress = chainConfig.multiChainValidatorAddress;

  // 构造 ValidationId (bytes21)
  const validatorType = 1; // MODULE_TYPE_VALIDATOR
  const validationId = `0x${validatorType.toString(16).padStart(2, '0')}${multiChainValidatorAddress.slice(2)}`.slice(0, 44);

  // 构造 validatorData (owner 地址)
  const validatorData = owner.slice(0, 42) as `0x${string}`;

  // hookData 为空
  const hookData = '0x' as `0x${string}`;

  // initConfig 为空数组
  const initConfig: `0x${string}`[] = [];

  // 编码 initialize 调用
  return encodeFunctionData({
    abi: [{
      inputs: [
        { name: '_rootValidator', type: 'bytes21' },
        { name: 'hook', type: 'address' },
        { name: 'validatorData', type: 'bytes' },
        { name: 'hookData', type: 'bytes' },
        { name: 'initConfig', type: 'bytes[]' },
      ],
      name: 'initialize',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    }],
    functionName: 'initialize',
    args: [
      validationId,
      multiChainValidatorAddress as Address,
      validatorData,
      hookData,
      initConfig,
    ],
  });
}
```

---

## 5. 关键数据结构

### 5.1 ValidationId

```solidity
// bytes21 类型
// 格式: [1字节类型][20字节地址]
type ValidationId is bytes21;
```

**示例**:
```
0x01 + 0x1234567890123456789012345678901234567890
= 0x011234567890123456789012345678901234567890
```

### 5.2 ValidationConfig

```solidity
struct ValidationConfig {
    uint32 nonce;  // 当前 nonce 值
    IHook hook;    // 关联的钩子合约
}
```

### 5.3 初始化参数

```solidity
struct InitializeParams {
    ValidationId rootValidator;  // 根验证器 ID
    IHook hook;                   // 钩子地址
    bytes validatorData;          // 验证器数据
    bytes hookData;               // 钩子数据
    bytes[] initConfig;           // 额外配置
}
```

---

## 6. 安全考虑

### 6.1 防止重复初始化

- `initialize()` 方法检查 `rootValidator` 是否已设置
- 如果已初始化，会抛出 `AlreadyInitialized` 错误

### 6.2 地址确定性

- 使用 CREATE2 确保地址确定性
- 相同的 `data` 和 `salt` 总是生成相同地址
- 可以提前预测地址并准备资金

### 6.3 验证器验证

- 初始化时验证验证器类型
- 必须为 `VALIDATOR` 或 `PERMISSION` 类型
- 验证器必须实现 `IValidator` 接口

### 6.4 初始化失败处理

- 如果初始化失败，整个交易会回滚
- 代理合约不会留下未初始化的状态

---

## 7. Gas 优化

### 7.1 使用代理模式

- 实现合约只需部署一次
- 每个账户只是轻量级代理合约
- 大幅降低部署成本

### 7.2 使用 CREATE2

- 确定性地址生成，无需额外计算
- 可以提前预测地址，优化用户体验

### 7.3 初始化数据优化

- 使用紧凑的数据结构
- 避免不必要的数据传递

---

## 8. 错误处理

### 8.1 常见错误

| 错误 | 原因 | 解决方案 |
|------|------|----------|
| `AlreadyInitialized` | 账户已初始化 | 检查账户状态，使用已存在的账户 |
| `InvalidValidator` | 验证器地址无效 | 检查验证器地址配置 |
| `InvalidValidationType` | 验证器类型错误 | 确保验证器类型为 VALIDATOR 或 PERMISSION |
| `InitializeError` | 初始化调用失败 | 检查初始化数据格式 |
| `ImplementationNotDeployed` | 实现合约未部署 | 确保 Kernel 实现合约已部署 |

### 8.2 错误处理示例

```typescript
try {
  const address = await accountManager.createAndDeployAccount(
    owner,
    chainId,
    signerPrivateKey
  );
  console.log('Account created:', address);
} catch (error) {
  if (error.message.includes('AlreadyInitialized')) {
    // 账户已存在，使用现有账户
    const existing = await accountManager.getAccount(owner, chainId);
    return existing.address;
  } else if (error.message.includes('InvalidValidator')) {
    // 验证器配置错误
    throw new Error('Validator address not configured');
  } else {
    // 其他错误
    throw error;
  }
}
```

---

## 9. 测试场景

### 9.1 基本创建流程

```typescript
// 1. 预测地址
const predicted = await predictAccountAddress(owner, chainId);

// 2. 创建账户
const address = await createAccount(owner, chainId, privateKey);

// 3. 验证地址一致
expect(address).toBe(predicted);

// 4. 验证账户已部署
const code = await provider.getCode(address);
expect(code).not.toBe('0x');
```

### 9.2 重复创建处理

```typescript
// 1. 第一次创建
const address1 = await createAccount(owner, chainId, privateKey);

// 2. 第二次创建（应该返回相同地址）
const address2 = await createAccount(owner, chainId, privateKey);

// 3. 验证地址相同
expect(address1).toBe(address2);
```

### 9.3 不同链创建

```typescript
// 同一 owner 在不同链上创建账户
const address1 = await createAccount(owner, 5000, privateKey);  // Mantle 主网
const address2 = await createAccount(owner, 5003, privateKey);  // Mantle Sepolia

// 地址应该不同（因为 salt 不同）
expect(address1).not.toBe(address2);
```

---

## 10. 总结

### 10.1 流程特点

1. **确定性地址**: 使用 CREATE2 确保地址可预测
2. **代理模式**: 降低部署成本，所有账户共享实现合约
3. **模块化初始化**: 支持灵活的验证器配置
4. **安全可靠**: 多重检查防止错误初始化

### 10.2 关键步骤

1. ✅ 预测账户地址（可选）
2. ✅ 构造初始化数据
3. ✅ 生成盐值
4. ✅ 调用 Factory 创建账户
5. ✅ 部署代理合约
6. ✅ 初始化账户
7. ✅ 安装验证器
8. ✅ 返回账户地址

### 10.3 最佳实践

- 在创建前预测地址，检查是否已存在
- 使用合适的验证器类型
- 正确处理初始化错误
- 保存账户信息以便后续使用
- 考虑 Gas 优化策略

---

## 附录

### A. 相关合约地址

**Mantle Sepolia 测试网**:
- EntryPoint: `0x0000000071727De22E5E9d8BAf0edAc6f37da032`
- Kernel Implementation: `0x94F097E1ebEB4ecA3AAE54cabb08905B239A7D27`
- KernelFactory: `0x6723b44Abeec4E71eBE3232BD5B455805baDD22f`
- MultiChainValidator: (需配置)

### B. 相关文档

- [智能合约代码结构分析](./智能合约代码结构分析.md)
- [部署指南](../DEPLOY.md)
- [ERC-4337 规范](https://eips.ethereum.org/EIPS/eip-4337)
- [ERC-7579 规范](https://eips.ethereum.org/EIPS/eip-7579)

---

**文档结束**
