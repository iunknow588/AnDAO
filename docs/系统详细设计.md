# AnDaoWallet HTML5 版本系统详细设计

## 文档信息

- **项目名称**: AnDaoWallet HTML5 版本（智能合约钱包 PWA）
- **文档版本**: 1.0
- **创建日期**: 2024年
- **最后更新**: 2024年
- **文档状态**: 开发中
- **对应文档**: 架构设计 v1.0、系统概述 v1.0

## 目录

1. [概述](#1-概述)
2. [核心模块详细设计](#2-核心模块详细设计)
3. [接口设计](#3-接口设计)
4. [数据流设计](#4-数据流设计)
5. [数据结构设计](#5-数据结构设计)
6. [错误处理设计](#6-错误处理设计)
7. [安全设计](#7-安全设计)
8. [性能优化设计](#8-性能优化设计)

---

## 1. 概述

### 1.1 文档目的

本文档提供 AnDaoWallet HTML5 版本的详细设计说明，包括：
- 各核心模块的详细实现设计
- 接口定义和调用规范
- 数据流和状态管理设计
- 错误处理和安全机制
- 性能优化策略

### 1.2 设计原则

1. **模块化设计**: 功能模块独立，接口清晰
2. **类型安全**: 全面使用 TypeScript 类型定义
3. **错误处理**: 完善的错误处理和用户提示
4. **安全性**: 密钥本地加密存储，遵循安全最佳实践
5. **可扩展性**: 支持插件系统和多链扩展

### 1.3 设计假设与约束

- **PWA 约束**：无后台常驻任务，长时间轮询需在前台或受限的 Service Worker 内执行。
- **网络波动**：Bundler/Paymaster 可能不可用，必须有降级路径（直连 EntryPoint、自付 Gas）。
- **密钥策略**：默认不导出明文密钥，导出/导入需二次确认与额外校验。
- **硬件钱包**：当前未集成，后续需要单独的威胁建模与数据流。
- **资源限制**：移动端内存上限 50MB，长列表默认虚拟滚动。
- **无中心化后端**：不自建业务服务器，不落地用户数据；仅依赖链上 RPC、Bundler/Paymaster 等第三方服务。

---

## 2. 核心模块详细设计

### 2.1 账户管理器 (AccountManager) ✅

#### 2.1.1 模块职责

- 管理智能合约账户的创建、查询和状态管理
- 与 Kernel Factory 合约交互
- 账户地址的确定性预测
- 多链账户管理

#### 2.1.2 类设计（已实现）

```typescript
class AccountManager {
  private accounts: Map<string, AccountInfo>;
  
  // 初始化 ✅
  async init(): Promise<void>;
  
  // 创建账户 ✅
  async createAccount(
    owner: Address, 
    chainId: number, 
    signerPrivateKey?: Hex
  ): Promise<Address>;
  
  // 获取账户地址 ✅
  async getAccountAddress(
    owner: Address, 
    chainId: number
  ): Promise<Address | null>;
  
  // 获取账户信息 ✅
  async getAccount(
    owner: Address, 
    chainId: number
  ): Promise<AccountInfo | null>;
  
  // 获取所有账户 ✅
  async getAllAccounts(): Promise<AccountInfo[]>;
  
  // 检查账户是否存在 ✅
  async accountExists(
    address: Address, 
    chainId: number
  ): Promise<boolean>;
}
```

#### 2.1.3 关键方法实现 ✅

**createAccount 方法**（已实现）:
1. ✅ 验证链配置（从 chains.ts 获取）
2. ✅ 构造初始化数据（initData，包含 MultiChainValidator 地址）
3. ✅ 生成 salt（基于 owner 和 chainId）
4. ✅ 调用 Factory.getAddress 预测地址
5. ✅ 如果提供 signerPrivateKey，调用 Factory.createAccount 部署
6. ⚠️ TODO：Bundler/Factory 不可用时的重试与降级（仅预测地址并提示）

**实现位置**: `src/services/AccountManager.ts`

**getAccountAddress 方法**（已实现）:
1. ✅ 先查找已创建的账户
2. ✅ 如果未找到，使用 Factory.getAddress 预测地址
3. ✅ 返回账户地址

---

### 2.2 交易中继器 (TransactionRelayer)

#### 2.2.1 模块职责（已实现，需增强）

- 构造 UserOperation ✅
- 签名 UserOperation（EIP-191）✅
- 发送 UserOperation 到 Bundler ✅
- 支持单笔和批量交易 ✅
- ⚠️ 需要内置 Bundler 故障转移与「直发 EntryPoint + 自付 Gas」降级模式

#### 2.2.2 类设计（已实现）

```typescript
class TransactionRelayer {
  // 发送单笔交易 ✅
  async sendTransaction(
    accountAddress: Address,
    chainId: number,
    target: Address,
    data: Hex,
    signerPrivateKey?: Hex
  ): Promise<Hash>;
  
  // 发送批量交易 ✅
  async sendBatch(
    accountAddress: Address,
    chainId: number,
    transactions: Array<{ target: Address; value: bigint; data: Hex }>,
    signerPrivateKey?: Hex
  ): Promise<Hash>;
  
  // 构造 UserOperation ✅
  private async buildUserOperation(...): Promise<UserOperation>;
  
  // 签名 UserOperation ✅
  private async signUserOperation(...): Promise<UserOperation>;
}
```

**实现位置**: `src/services/TransactionRelayer.ts`

#### 2.2.3 关键方法实现

**buildUserOperation 方法**（已实现）:
1. ✅ 获取账户 nonce（从 EntryPoint）
2. ✅ 获取当前 Gas 价格
3. ✅ 构造 callData（调用 Kernel.execute）
4. ✅ 估算 Gas（使用 Bundler 或降级方案）
5. ✅ 构造完整的 UserOperation
6. ⚠️ TODO：在 Bundler 不支持的链上走本地估算 + 明确提示用户需自付 Gas

**signUserOperation 方法**（已实现）:
1. ✅ 计算 UserOperation 哈希（getUserOpHash）
2. ✅ 使用 EIP-191 标准签名（toEthSignedMessageHash）
3. ✅ 返回签名后的 UserOperation

#### 2.2.4 三段式降级策略（新增）

1. **Bundler 优先**：按健康度/延迟排序 Bundler 列表，失败即刻切换，并重新获取 nonce、Gas。
2. **直连 EntryPoint**：在所有 Bundler 不可用时，构造 `Kernel.execute` 的 raw transaction，用户自付 Gas；需在 UI 中提示手续费变化。
3. **离线导出**：若 RPC 亦不可用，允许导出签名后的 UserOperation 供命令行/其他端重放，并保留 userOpHash 供追踪。

> 注意：降级链路必须重新计算 `userOpHash`，并要求用户确认新的费用来源，以防旧签名重放。

---

### 2.3 Bundler 客户端 (BundlerClient)

#### 2.3.1 模块职责

- 与 ERC-4337 Bundler 服务交互
- 支持多 Bundler 服务商故障转移
- UserOperation 发送和状态查询
- Gas 估算

#### 2.3.2 类设计（部分实现）

```typescript
class BundlerClient {
  private bundlers: BundlerConfig[];
  private currentBundler: BundlerConfig | null;
  
  // 添加 Bundler
  addBundler(config: BundlerConfig): void;
  
  // 发送 UserOperation
  async sendUserOperation(
    userOp: UserOperation
  ): Promise<Hash>;
  
  // 估算 Gas
  async estimateUserOperationGas(
    userOp: UserOperation
  ): Promise<GasEstimate>;
  
  // 查询交易状态
  async getUserOperationReceipt(
    userOpHash: Hash
  ): Promise<UserOperationReceipt>;
}
```

#### 2.3.3 故障转移机制

1. 按优先级排序 Bundler 列表
2. 尝试发送到第一个 Bundler
3. 如果失败，自动切换到下一个
4. 所有 Bundler 都失败时抛出错误
5. ⚠️ TODO：切换时需要重新拉取 nonce/估算，避免因重放导致的费用高估或失败

#### 2.3.4 健康检查与优先级

- 每个 Bundler 维护 `healthScore`（成功率、延迟、最近失败时间）。
- `BundlerClient` 周期性执行 `eth_chainId` 与 `eth_supportedEntryPoints` 探测，失败时降低优先级。
- 向上层暴露「可切换 Bundler」事件，便于 UI 提示用户网络状态。

---

### 2.4 安全存储 (SecurityVault)

#### 2.4.1 模块职责

- 使用 AES-GCM 加密存储敏感数据
- PBKDF2 密钥派生
- 安全的密钥管理

#### 2.4.2 类设计

```typescript
class SecurityVault {
  private encryptionKey: CryptoKey | null;
  
  // 派生加密密钥
  async deriveKey(
    password: string, 
    salt: Uint8Array
  ): Promise<CryptoKey>;
  
  // 存储加密数据
  async setItem(
    key: string, 
    value: any, 
    password: string
  ): Promise<void>;
  
  // 读取并解密数据
  async getItem<T>(
    key: string, 
    password: string
  ): Promise<T | null>;
  
  // 删除数据
  async removeItem(key: string): Promise<void>;
}
```

#### 2.4.3 加密流程

1. 使用 PBKDF2 从密码派生密钥（100,000 次迭代）
2. 生成随机 IV（12 字节）
3. 使用 AES-GCM 加密数据
4. 存储加密数据、IV 和 salt
5. ⚠️ TODO：为不同数据域使用独立 salt/label，防止同明文重放；密码更新时需触发全量重加密并提供回滚路径。

#### 2.4.4 密钥轮换与双写策略（新增）

1. 为每个数据域维护 `keyVersion`，与密文一同持久化。
2. 当用户修改密码时，先生成新密钥，对所有数据执行「双写」：新版本写入成功后才删除旧密钥。
3. 若过程中断，凭 `keyVersion` 判断是否需要回滚/重试，避免出现「部分数据新密钥、部分旧密钥」的异常状态。

---

### 2.5 认证服务 (AuthService)

#### 2.5.1 模块职责（部分实现）

- 用户登录/解锁
- 会话管理
- 自动锁定机制
- 密码修改
- ⚠️ TODO：前台/后台切换的自动锁定策略与事件源（可见性、焦点、空闲时间）需统一

#### 2.5.2 类设计

```typescript
class AuthService {
  private session: Session | null;
  private autoLockTimer: NodeJS.Timeout | null;
  
  // 登录
  async login(
    password: string, 
    userId?: string
  ): Promise<boolean>;
  
  // 登出
  async logout(): Promise<void>;
  
  // 检查认证状态
  isAuthenticated(): boolean;
  
  // 延长会话
  async extendSession(): Promise<void>;
  
  // 修改密码
  async changePassword(
    oldPassword: string, 
    newPassword: string
  ): Promise<boolean>;
}
```

#### 2.5.3 自动锁定机制

- 默认 5 分钟无活动自动锁定
- 监听用户活动事件（鼠标、键盘、触摸等）
- 活动时重置锁定计时器
- 锁定后清除会话和加密密钥
- ⚠️ PWA 场景需区分「标签页不可见」与「真正空闲」，避免误锁或漏锁

#### 2.5.4 前后台策略拆分（新增）

- **受限模式**：标签页进入后台后立即切换到受限模式，仅禁止敏感操作，保留解锁状态 60 秒，避免用户切回即被登出。
- **完全锁定**：连续 5 分钟无交互或受限模式超时后，执行完整锁定流程（清除密钥、销毁 Session）。
- **事件源统一**：使用 Visibility API + IdleDetector（可用时）驱动状态，减少多源监听导致的竞态。

---

### 2.6 守护人与社交恢复服务 (GuardianService) ♻️

#### 2.6.1 模块职责

- 管理守护人列表、阈值与权限。
- 协调社交恢复流程（请求、投票、执行、取消）。
- 与 `TwoPhaseCommitService` 协同存储加密的恢复凭据。

#### 2.6.2 状态机设计

```
IDLE → INITIATED → VOTING → (EXECUTABLE | REJECTED) → EXECUTED
                                ↘︎ CANCELLED
```

- `INITIATED`：发起人提交恢复请求，记录目标账户、提案时间、延迟窗口。
- `VOTING`：守护人签名提交，超过阈值且延迟时间满足后进入 `EXECUTABLE`。
- `EXECUTED`：调用恢复插件完成 owner 切换；失败则回退到 `INITIATED`。

#### 2.6.3 关键接口

```typescript
class GuardianService {
  async initiateRecovery(payload: RecoveryPayload): Promise<string>;
  async voteForRecovery(recoveryId: string, signature: Hex): Promise<void>;
  async executeRecovery(recoveryId: string): Promise<void>;
  async cancelRecovery(recoveryId: string): Promise<void>;
  subscribe(listener: (event: RecoveryEvent) => void): () => void;
}
```

#### 2.6.4 UI 与安全要求

- 所有状态变化需呈现倒计时与缺失票数。
- 进入 `EXECUTABLE` 前必须再次验证当前账户持有人身份，防止本地状态被篡改。
- 与自动锁定策略联动，确保在受限模式下无法无感发起恢复。

---

## 3. 接口设计

### 3.1 存储适配器接口

```typescript
interface StorageAdapter {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T): Promise<void>;
  remove(key: string): Promise<void>;
  clear(): Promise<void>;
}
```

### 3.2 UserOperation 接口

```typescript
interface UserOperation {
  sender: string;              // 智能合约账户地址
  nonce: bigint;              // 账户 nonce
  initCode: string;           // 初始化代码（首次创建时）
  callData: string;           // 调用数据
  callGasLimit: bigint;       // 调用 Gas 限制
  verificationGasLimit: bigint; // 验证 Gas 限制
  preVerificationGas: bigint;  // 预验证 Gas
  maxFeePerGas: bigint;       // 最大 Gas 价格
  maxPriorityFeePerGas: bigint; // 最大优先费用
  paymasterAndData: string;    // Paymaster 数据
  signature: string;           // 签名
  // 建议：显式携带链标识/版本号便于多 Bundler 调试
}
```

### 3.3 链配置接口

```typescript
interface ChainConfig {
  chainId: number;
  name: string;
  rpcUrl: string;
  bundlerUrl: string;
  paymasterAddress?: string;
  kernelFactoryAddress?: string;
  entryPointAddress?: string;
  nativeCurrency: {
    name: string;
    symbol: string;
    decimals: number;
  };
}
```

---

## 4. 数据流设计

### 4.1 账户创建流程

```
用户输入 owner 地址
  ↓
AccountManager.createAccount()
  ↓
构造 initData 和 salt
  ↓
Factory.getAddress() 预测地址
  ↓
[可选] Factory.createAccount() 部署账户
  ↓
保存账户信息到本地存储
  ↓
返回账户地址
  ↘︎ 错误分支：Factory/Bundler 不可用 → 仅预测地址并提示用户稍后部署
```

### 4.2 交易发送流程

```
用户构造交易（目标地址、数据）
  ↓
TransactionRelayer.sendTransaction()
  ↓
获取账户 nonce（EntryPoint.getNonce）
  ↓
构造 callData（Kernel.execute）
  ↓
估算 Gas（Bundler.estimateUserOperationGas）
  ↓
构造 UserOperation
  ↓
签名 UserOperation（EIP-191）
  ↓
发送到 Bundler（Bundler.sendUserOperation）
  ↓
返回交易哈希
  ↘︎ 降级分支：Bundler 不可用 → 本地估算 + RPC 直发，提示需自付 Gas
  ↘︎ 纯前端约束：无后端重试队列，失败需用户前台重试
```

### 4.3 登录流程

```
用户输入密码
  ↓
AuthService.login()
  ↓
验证密码（尝试解密测试数据）
  ↓
创建会话（30 分钟有效期）
  ↓
保存会话到本地存储
  ↓
启动自动锁定机制
  ↓
设置活动监听器
  ↘︎ 异常分支：解密失败 → 限速提示并记录安全日志
  ↘︎ PWA/纯前端约束：标签页隐藏或失焦立即/快速锁定；无后端会话
```

---

## 5. 数据结构设计

### 5.1 AccountInfo

```typescript
interface AccountInfo {
  address: string;      // 账户地址
  chainId: number;      // 链 ID
  owner: string;         // 所有者地址（签名者）
  createdAt: number;     // 创建时间戳
}
```

### 5.2 Session

```typescript
interface Session {
  userId: string;        // 用户 ID
  createdAt: number;     // 创建时间
  expiresAt: number;     // 过期时间
  deviceId?: string;     // 可选：用于多端区分
}
```

### 5.3 Transaction

```typescript
interface Transaction {
  to: string;           // 目标地址
  value: bigint;        // 转账金额
  data: string;         // 调用数据
  chainId?: number;     // 可选链标识，便于多链批量交易
}
```

---

## 6. 错误处理设计

### 6.1 错误分类

1. **网络错误**: RPC 调用失败、Bundler 不可用
2. **合约错误**: 账户不存在、Gas 不足、签名验证失败
3. **用户错误**: 密码错误、地址格式错误
4. **系统错误**: 存储失败、加密失败

### 6.2 错误处理策略

- **网络错误**: 自动重试、故障转移
- **合约错误**: 返回详细错误信息给用户
- **用户错误**: 友好的错误提示
- **系统错误**: 记录日志，通知用户

### 6.3 错误码定义

```typescript
enum ErrorCode {
  NETWORK_ERROR = 'NETWORK_ERROR',
  CONTRACT_ERROR = 'CONTRACT_ERROR',
  AUTH_ERROR = 'AUTH_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  STORAGE_ERROR = 'STORAGE_ERROR',
  BUNDLER_UNAVAILABLE = 'BUNDLER_UNAVAILABLE',
}
```

---

## 7. 安全设计

### 7.1 密钥管理

- 私钥仅存储在本地（加密存储）
- 使用 AES-GCM 加密（256 位密钥）
- PBKDF2 密钥派生（100,000 次迭代）
- 每个数据项使用独立的 salt
- 密码修改需触发全量重加密，失败时需保留旧密钥以支持回滚

### 7.2 会话安全

- 会话有效期 30 分钟
- 5 分钟无活动自动锁定
- 会话数据加密存储
- 登出时清除所有敏感数据
- PWA 前后台切换时应立即锁定或提示用户确认

### 7.3 交易安全

- UserOperation 使用 EIP-191 标准签名
- 签名前验证所有参数
- 显示交易预览供用户确认
- 支持交易取消
- 在多 Bundler 失败后切换 RPC 时，需重新计算 userOpHash 防止签名重放

---

## 8. 性能优化设计

### 8.1 代码优化

- 路由级别的代码分割
- 组件懒加载
- Tree Shaking
- 资源压缩

### 8.2 运行时优化

- 使用 React.memo 减少重渲染
- 使用 useMemo 和 useCallback 缓存计算结果
- 虚拟滚动（长列表）
- 防抖和节流（用户输入）

### 8.3 网络优化

- RPC 请求缓存
- 批量请求合并
- 请求重试机制
- 故障转移
- 离线/弱网降级：切换为只读模式并缓存最近区块高度

---

## 总结

本文档详细描述了 AnDaoWallet HTML5 版本的核心模块设计、接口规范、数据流和错误处理机制。各模块遵循模块化设计原则，接口清晰，便于维护和扩展。

下一步工作：
1. 完善 Paymaster 集成与 Bundler 故障转移降级路径
2. 补齐社交恢复与延迟/条件交易插件实现
3. 完善自动锁定与密钥轮换策略，覆盖 PWA 前后台场景
4. 完善测试覆盖（离线/弱网、Bundler 不可用、密码轮换）

---

**文档版本历史**:
- v1.0 (2024): 初始版本

