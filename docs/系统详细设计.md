# AnDaoWallet HTML5 版本系统详细设计

## 文档信息

- **项目名称**: AnDaoWallet HTML5 版本（智能合约钱包 PWA）
- **文档版本**: 2.0
- **创建日期**: 2024年
- **最后更新**: 2025年1月
- **文档状态**: 开发中
- **对应文档**: 系统需求规格说明书（SRS）与系统概要设计说明书（本文件聚焦“怎么做”）

## 目录

1. [概述](#1-概述)
2. [三路径架构详细设计](#2-三路径架构详细设计)
3. [核心模块详细设计](#3-核心模块详细设计)
4. [接口设计](#4-接口设计)
5. [数据流设计](#5-数据流设计)
6. [数据结构设计](#6-数据结构设计)
7. [错误处理设计](#7-错误处理设计)
8. [安全设计](#8-安全设计)
9. [性能优化设计](#9-性能优化设计)

---

## 1. 概述

### 1.1 文档目的

本文档提供 AnDaoWallet HTML5 版本的**详细设计说明（内部设计）**，聚焦：
- 内部模块的职责拆分与协作方式（实现视角）
- 关键算法与逻辑（例如两阶段提交自动发送策略、安全边界）
- 详细的数据结构与接口规格
- 错误处理、安全机制与性能策略的实现细则

### 1.2 设计原则

1. **三路径统一**：同一应用，三种入口，满足不同用户需求
2. **模块化设计**: 功能模块独立，接口清晰
3. **类型安全**: 全面使用 TypeScript 类型定义
4. **错误处理**: 完善的错误处理和用户提示
5. **安全性**: 密钥本地加密存储，遵循安全最佳实践
6. **可扩展性**: 支持插件系统和多链扩展

### 1.3 设计假设与约束

- **PWA 约束**：无后台常驻任务，长时间轮询需在前台或受限的 Service Worker 内执行
- **网络波动**：Bundler/Paymaster 可能不可用，必须有降级路径（直连 EntryPoint、自付 Gas）
- **密钥策略**：默认不导出明文密钥，导出/导入需二次确认与额外校验
- **自动生成密钥**：路径A和路径B自动生成智能账户密钥，用户无需提供EOA私钥
- **赞助商机制**：路径A依赖赞助商代付Gas，需要足够的活跃赞助商支持
- **硬件钱包**：当前未集成，后续需要单独的威胁建模与数据流
- **资源限制**：移动端内存上限 50MB，长列表默认虚拟滚动
- **无中心化后端**：不自建业务服务器，不落地用户数据；仅依赖链上 RPC、Bundler/Paymaster 等第三方服务

---

## 2. 三路径架构详细设计

### 2.1 架构概述

三路径的**外部行为/用户流程**已在《系统概要设计说明书》中定义（回答“做什么”）：

- `docs/系统概要设计说明书.md` → `6.2 三路径创建（概要数据流）`

本章后续内容聚焦三路径在实现侧的关键点（例如：参数校验、状态机、错误分支与服务协作）。

### 2.2 类型定义

领域模型（对外字段）与关键枚举已在《系统概要设计说明书》中统一定义（回答“做什么”）：

- `docs/系统概要设计说明书.md` → `7. 数据模型（领域模型）`

本文件仅在需要解释内部逻辑时引用这些类型；类型的最终来源以代码实现为准。

### 2.3 路径A：极简体验详细设计

#### 2.3.1 模块职责

- 自动生成智能账户密钥对（本地生成，加密存储）
- 预测智能合约账户地址
- 赞助商选择与申请管理
- 申请状态跟踪与轮询

#### 2.3.2 核心流程

```typescript
// 路径A创建流程
async function createAccountPathA(
  password: string,
  sponsorId?: string,
  inviteCode?: string
): Promise<AccountInfo> {
  // 1. 自动生成智能账户密钥对
  const { keyManagerService } = await import('@/services/KeyManagerService');
  const { address: ownerAddress, privateKey } = await keyManagerService.generatePrivateKey();
  
  // 2. 加密存储私钥
  await keyManagerService.savePrivateKey(ownerAddress, privateKey, password);
  
  // 3. 预测智能合约账户地址
  const predictedAddress = await accountManager.predictAccountAddress(
    ownerAddress,
    chainId
  );
  
  // 4. 选择赞助商（从列表或邀请码）
  const sponsor = await sponsorService.selectSponsor(sponsorId, inviteCode);
  
  // 5. 创建申请记录
  const application = await sponsorService.createApplication({
    accountAddress: predictedAddress,
    ownerAddress,
    sponsorId: sponsor.id,
    chainId,
  });
  
  // 6. 保存账户信息（状态为pending）
  const accountInfo: AccountInfo = {
    address: predictedAddress,
    chainId,
    owner: ownerAddress,
    userType: UserType.SIMPLE,
    creationPath: AccountCreationPath.PATH_A_SIMPLE,
    status: AccountStatus.PENDING,
    createdAt: Date.now(),
    sponsorId: sponsor.id,
    sponsorAddress: sponsor.address,
  };
  
  await accountManager.saveAccount(accountInfo);
  
  // 7. 返回账户信息（等待审核）
  return accountInfo;
}
```

#### 2.3.3 关键服务

**SponsorService**（新增）:
```typescript
class SponsorService {
  // 获取推荐赞助商列表
  async getRecommendedSponsors(): Promise<Sponsor[]>;
  
  // 通过邀请码选择赞助商
  async selectSponsorByInviteCode(inviteCode: string): Promise<Sponsor>;
  
  // 创建申请
  async createApplication(params: ApplicationParams): Promise<Application>;
  
  // 查询申请状态
  async getApplicationStatus(applicationId: string): Promise<ApplicationStatus>;
  
  // 轮询申请状态（用于路径A用户）
  async pollApplicationStatus(
    applicationId: string,
    onStatusChange: (status: ApplicationStatus) => void
  ): Promise<void>;
}
```

**实现位置**: `src/services/SponsorService.ts`（待实现）

### 2.4 路径B：标准模式详细设计

#### 2.4.1 模块职责

- EOA账户创建/导入
- 智能账户密钥生成（与EOA关联）
- Gas支付方式选择（自付或申请赞助）
- 双账户管理

#### 2.4.2 核心流程

```typescript
// 路径B创建流程
async function createAccountPathB(
  eoaPrivateKey: `0x${string}`,
  password: string,
  gasPaymentMethod: 'self' | 'sponsor'
): Promise<AccountInfo> {
  // 1. 从EOA私钥获取地址
  const eoaAddress = keyManagerService.getAddressFromPrivateKey(eoaPrivateKey);
  
  // 2. 生成智能账户密钥对（与EOA关联）
  const { address: ownerAddress, privateKey } = await keyManagerService.generatePrivateKey();
  await keyManagerService.savePrivateKey(ownerAddress, privateKey, password);
  
  // 3. 选择Gas支付方式
  if (gasPaymentMethod === 'self') {
    // 自付Gas：直接部署
    const accountAddress = await accountManager.createAndDeployAccount(
      ownerAddress,
      chainId,
      eoaPrivateKey  // 使用EOA私钥支付Gas
    );
    
    return {
      address: accountAddress,
      chainId,
      owner: ownerAddress,
      eoaAddress,
      userType: UserType.STANDARD,
      creationPath: AccountCreationPath.PATH_B_STANDARD,
      status: AccountStatus.DEPLOYED,
      createdAt: Date.now(),
      deployedAt: Date.now(),
    };
  } else {
    // 申请赞助商代付（类似路径A）
    const predictedAddress = await accountManager.predictAccountAddress(ownerAddress, chainId);
    const sponsor = await sponsorService.selectSponsor();
    const application = await sponsorService.createApplication({
      accountAddress: predictedAddress,
      ownerAddress,
      eoaAddress,  // 记录EOA地址
      sponsorId: sponsor.id,
      chainId,
    });
    
    return {
      address: predictedAddress,
      chainId,
      owner: ownerAddress,
      eoaAddress,
      userType: UserType.STANDARD,
      creationPath: AccountCreationPath.PATH_B_STANDARD,
      status: AccountStatus.PENDING,
      createdAt: Date.now(),
      sponsorId: sponsor.id,
    };
  }
}
```

### 2.5 路径C：成为赞助商详细设计

#### 2.5.1 模块职责

- 赞助商注册与链上登记
- Gas账户配置与管理
- 审核规则设置
- 渠道管理系统
- 申请审核与处理

#### 2.5.2 核心流程

```typescript
// 路径C注册流程
async function registerSponsor(
  eoaPrivateKey: `0x${string}`,
  sponsorInfo: SponsorInfo,
  gasAccountPrivateKey: `0x${string}`,
  rules: SponsorRules
): Promise<SponsorAccount> {
  // 1. 验证EOA账户
  const eoaAddress = keyManagerService.getAddressFromPrivateKey(eoaPrivateKey);
  
  // 2. 设置Gas支付账户
  const gasAccountAddress = keyManagerService.getAddressFromPrivateKey(gasAccountPrivateKey);
  
  // 3. 检查Gas账户余额
  const balance = await getBalance(gasAccountAddress);
  if (balance < parseEther('0.5')) {
    throw new Error('Gas账户余额不足，至少需要0.5 MNT');
  }
  
  // 4. 创建赞助商账户（链上注册）
  const sponsorId = await sponsorService.registerOnChain({
    sponsorAddress: eoaAddress,
    gasAccountAddress,
    sponsorInfo,
    rules,
  });
  
  // 5. 创建智能合约账户（可选，用于赞助商自己的使用）
  const { address: ownerAddress, privateKey } = await keyManagerService.generatePrivateKey();
  const accountAddress = await accountManager.createAndDeployAccount(
    ownerAddress,
    chainId,
    gasAccountPrivateKey  // 使用Gas账户支付
  );
  
  return {
    sponsorId,
    eoaAddress,
    gasAccountAddress,
    accountAddress,
    ownerAddress,
    rules,
  };
}
```

### 2.6 路径转换机制

#### 2.6.1 转换接口

```typescript
class AccountManager {
  /**
   * 根据路径创建账户
   */
  async createAccountByPath(
    path: AccountCreationPath,
    params: CreateAccountParams
  ): Promise<AccountInfo> {
    switch (path) {
      case AccountCreationPath.PATH_A_SIMPLE:
        return await this.createAccountPathA(params);
      case AccountCreationPath.PATH_B_STANDARD:
        return await this.createAccountPathB(params);
      case AccountCreationPath.PATH_C_SPONSOR:
        return await this.createAccountPathC(params);
      default:
        throw new Error(`Unknown path: ${path}`);
    }
  }
  
  /**
   * 路径转换
   */
  async convertPath(
    accountAddress: Address,
    targetPath: AccountCreationPath
  ): Promise<AccountInfo> {
    const account = await this.getAccountByAddress(accountAddress);
    if (!account) {
      throw new Error('Account not found');
    }
    
    // 路径转换逻辑
    if (account.creationPath === AccountCreationPath.PATH_A_SIMPLE) {
      if (targetPath === AccountCreationPath.PATH_B_STANDARD) {
        // 添加EOA账户
        return await this.addEOAToAccount(account);
      }
    }
    
    // ... 其他转换逻辑
  }
}
```

---

## 3. 核心模块详细设计

### 3.1 账户管理器 (AccountManager) ✅

#### 3.1.1 模块职责（扩展）

- 管理智能合约账户的创建、查询和状态管理
- 与 Kernel Factory 合约交互
- 账户地址的确定性预测
- 多链账户管理
- **支持三路径创建**（新增）
- **路径转换**（新增）

#### 3.1.2 类设计（扩展）

```typescript
class AccountManager {
  private accounts: Map<string, AccountInfo>;
  
  // 初始化 ✅
  async init(): Promise<void>;
  
  // 根据路径创建账户（新增）
  async createAccountByPath(
    path: AccountCreationPath,
    params: CreateAccountParams
  ): Promise<AccountInfo>;
  
  // 路径A：极简体验创建（新增）
  async createAccountPathA(
    password: string,
    sponsorId?: string,
    inviteCode?: string
  ): Promise<AccountInfo>;
  
  // 路径B：标准模式创建（新增）
  async createAccountPathB(
    eoaPrivateKey: `0x${string}`,
    password: string,
    gasPaymentMethod: 'self' | 'sponsor'
  ): Promise<AccountInfo>;
  
  // 路径C：成为赞助商（新增）
  async registerSponsor(
    eoaPrivateKey: `0x${string}`,
    sponsorInfo: SponsorInfo,
    gasAccountPrivateKey: `0x${string}`,
    rules: SponsorRules
  ): Promise<SponsorAccount>;
  
  // 创建账户（原有，保持兼容）
  async createAccount(
    owner: Address, 
    chainId: number, 
    signerPrivateKey?: Hex
  ): Promise<Address>;
  
  // 路径转换（新增）
  async convertPath(
    accountAddress: Address,
    targetPath: AccountCreationPath
  ): Promise<AccountInfo>;
  
  // 获取账户地址 ✅
  async getAccountAddress(
    owner: Address, 
    chainId: number
  ): Promise<Address | null>;
  
  // 获取账户信息 ✅
  async getAccount(
    owner: Address, 
    chainId: number
  ): Promise<AccountInfo | null>;
  
  // 获取所有账户 ✅
  async getAllAccounts(): Promise<AccountInfo[]>;
  
  // 检查账户是否存在 ✅
  async accountExists(
    address: Address, 
    chainId: number
  ): Promise<boolean>;
}
```

**实现位置**: `src/services/AccountManager.ts`

### 3.2 存储提供者服务 (StorageProviderService) ⚠️ 待实现

#### 3.2.1 模块职责

- 管理可插拔的存储提供者
- 提供统一的存储接口
- 支持默认IPFS存储和赞助商自定义存储
- 存储标识符验证和类型识别

#### 3.2.2 核心接口设计

```typescript
/**
 * 存储提供者接口
 */
export interface IStorageProvider {
  readonly type: StorageProviderType;
  readonly name: string;
  
  // 存储数据
  add(data: any): Promise<string>;
  
  // 获取数据
  get<T = any>(identifier: string): Promise<T>;
  
  // 验证存储标识符
  isValid(identifier: string): boolean;
  
  // 获取访问URL（可选）
  getAccessUrl?(identifier: string): string | null;
  
  // 批量获取（可选）
  getBatch?<T = any>(identifiers: string[]): Promise<T[]>;
}

/**
 * 存储提供者管理器
 */
export class StorageProviderManager {
  // 注册存储提供者
  register(provider: IStorageProvider): void;
  
  // 获取存储提供者
  getProvider(type: StorageProviderType): IStorageProvider;
  
  // 获取默认提供者
  getDefaultProvider(): IStorageProvider;
  
  // 根据标识符自动选择提供者
  getProviderByIdentifier(identifier: string): IStorageProvider;
}
```

#### 3.2.3 默认IPFS实现

```typescript
/**
 * 默认IPFS存储提供者
 */
export class DefaultIPFSStorageProvider implements IStorageProvider {
  readonly type = StorageProviderType.IPFS;
  readonly name = 'IPFS (Default)';
  
  // 使用公共IPFS网关（Pinata/Web3.Storage等）
  async add(data: any): Promise<string>;
  async get<T = any>(cid: string): Promise<T>;
  isValid(identifier: string): boolean;
  getAccessUrl(cid: string): string | null;
}
```

#### 3.2.4 自定义存储实现

```typescript
/**
 * 赞助商自定义存储提供者
 */
export class CustomStorageProvider implements IStorageProvider {
  readonly type = StorageProviderType.CUSTOM;
  readonly name: string;
  
  // 支持自定义端点、API密钥等
  constructor(config: CustomStorageConfig);
  async add(data: any): Promise<string>;
  async get<T = any>(identifier: string): Promise<T>;
  isValid(identifier: string): boolean;
}
```

**实现位置**: 
- `src/interfaces/IStorageProvider.ts`（接口定义）
- `src/services/storage/DefaultIPFSStorageProvider.ts`（默认实现）
- `src/services/storage/StorageProviderManager.ts`（管理器）
- `src/services/storage/CustomStorageProvider.ts`（自定义实现）

### 3.3 赞助商服务 (SponsorService) ⚠️ 待实现

#### 3.3.1 模块职责

- 赞助商注册与管理
- 申请创建与审核
- 渠道管理
- 审核规则引擎
- 数据分析与效果追踪
- **存储配置管理**（新增）

#### 3.3.2 类设计

```typescript
class SponsorService {
  // 获取推荐赞助商列表
  async getRecommendedSponsors(): Promise<Sponsor[]>;
  
  // 通过邀请码选择赞助商
  async selectSponsorByInviteCode(inviteCode: string): Promise<Sponsor>;
  
  // 创建申请（使用存储提供者）
  async createApplication(params: ApplicationParams): Promise<Application>;
  
  // 查询申请状态
  async getApplicationStatus(applicationId: string): Promise<ApplicationStatus>;
  
  // 轮询申请状态
  async pollApplicationStatus(
    applicationId: string,
    onStatusChange: (status: ApplicationStatus) => void
  ): Promise<void>;
  
  // 赞助商：注册链上
  async registerOnChain(params: SponsorRegistrationParams): Promise<string>;
  
  // 赞助商：审核申请
  async reviewApplication(
    sponsorId: string,
    applicationId: string,
    decision: 'approve' | 'reject',
    reason?: string
  ): Promise<void>;
  
  // 赞助商：创建账户（代付Gas）
  async deployAccountForUser(
    sponsorId: string,
    applicationId: string
  ): Promise<Hash>;
  
  // 渠道管理
  async createChannel(sponsorId: string, channelInfo: ChannelInfo): Promise<string>;
  async getChannelStats(channelId: string): Promise<ChannelStats>;
  
  // 存储配置管理（新增）
  async setSponsorStorageConfig(
    sponsorId: string,
    config: StorageProviderConfig
  ): Promise<void>;
  
  async getSponsorStorageConfig(sponsorId: string): Promise<StorageProviderConfig | null>;
}
```

**实现位置**: `src/services/SponsorService.ts`（待实现）

### 3.3 交易中继器 (TransactionRelayer)

#### 3.3.1 模块职责（已实现，需增强）

- 构造 UserOperation ✅
- 签名 UserOperation（EIP-191）✅
- 发送 UserOperation 到 Bundler ✅
- 支持单笔和批量交易 ✅
- ⚠️ 需要内置 Bundler 故障转移与「直发 EntryPoint + 自付 Gas」降级模式

**实现位置**: `src/services/TransactionRelayer.ts`

### 3.4 密钥管理服务 (KeyManagerService) ✅

#### 3.4.1 模块职责（扩展）

- 自动生成密钥对（用于路径A和路径B）
- 保存和获取签名者私钥（加密存储）
- 从私钥获取地址
- 助记词生成和恢复（新增）

#### 3.4.2 类设计（扩展）

```typescript
class KeyManagerService {
  // 生成新的私钥（用于路径A和路径B）
  async generatePrivateKey(): Promise<{ address: Address; privateKey: Hex }>;
  
  // 生成助记词（新增）
  async generateMnemonic(): Promise<string>;
  
  // 从助记词恢复私钥（新增）
  async recoverFromMnemonic(mnemonic: string): Promise<{ address: Address; privateKey: Hex }>;
  
  // 保存签名者私钥（加密存储）
  async savePrivateKey(
    address: Address,
    privateKey: Hex,
    password: string
  ): Promise<void>;
  
  // 获取签名者私钥（需要密码解密）
  async getPrivateKey(
    address: Address,
    password: string
  ): Promise<Hex | null>;
  
  // 从私钥获取地址
  getAddressFromPrivateKey(privateKey: Hex): Address;
}
```

**实现位置**: `src/services/KeyManagerService.ts`

---

## 4. 接口设计

### 4.1 存储提供者接口（新增）

```typescript
/**
 * 存储提供者接口
 * 所有存储方案必须实现此接口
 */
export interface IStorageProvider {
  readonly type: StorageProviderType;
  readonly name: string;
  
  // 存储数据
  add(data: any): Promise<string>;
  
  // 获取数据
  get<T = any>(identifier: string): Promise<T>;
  
  // 验证存储标识符
  isValid(identifier: string): boolean;
  
  // 获取访问URL（可选）
  getAccessUrl?(identifier: string): string | null;
  
  // 批量获取（可选）
  getBatch?<T = any>(identifiers: string[]): Promise<T[]>;
}

/**
 * 存储提供者类型
 */
export enum StorageProviderType {
  IPFS = 'ipfs',           // IPFS存储（默认）
  ARWEAVE = 'arweave',     // Arweave存储
  CUSTOM = 'custom',       // 自定义存储（赞助商）
}

/**
 * 存储提供者配置
 */
export interface StorageProviderConfig {
  type: StorageProviderType;
  name: string;
  config?: Record<string, any>;  // 存储提供者特定配置
  endpoint?: string;              // 自定义端点（可选）
}
```

### 4.2 账户信息接口（扩展）

```typescript
interface AccountInfo {
  address: string;                 // 智能合约账户地址
  chainId: number;                  // 链 ID
  owner: string;                   // 签名者地址（智能账户控制密钥）
  eoaAddress?: string;             // EOA地址（路径B和C）
  userType: UserType;              // 用户类型
  creationPath: AccountCreationPath; // 创建路径
  status: AccountStatus;           // 账户状态
  createdAt: number;                // 创建时间戳
  deployedAt?: number;              // 部署时间戳（可选）
  sponsorId?: string;               // 赞助商ID（路径A）
  sponsorAddress?: string;          // 赞助商地址（路径A）
}
```

### 4.3 赞助商接口（新增）

```typescript
interface Sponsor {
  id: string;
  address: Address;
  name: string;
  description?: string;
  approvalRate: number;        // 通过率
  avgWaitTime: number;         // 平均等待时间（分钟）
  totalSponsored: number;      // 总赞助账户数
  availableBalance: bigint;     // 可用Gas余额
  storageType?: StorageProviderType;  // 存储类型（新增）
  storageConfig?: StorageProviderConfig;  // 存储配置（新增）
}

interface Application {
  id: string;
  accountAddress: Address;
  ownerAddress: Address;
  sponsorId: string;
  chainId: number;
  status: 'pending' | 'approved' | 'rejected' | 'deployed';
  createdAt: number;
  reviewedAt?: number;
  deployedAt?: number;
  storageIdentifier?: string;      // 存储标识符（新增）
  storageType?: StorageProviderType;  // 存储类型（新增）
}
```

### 4.3 UserOperation 接口

```typescript
interface UserOperation {
  sender: string;              // 智能合约账户地址
  nonce: bigint;              // 账户 nonce
  initCode: string;           // 初始化代码（首次创建时）
  callData: string;           // 调用数据
  callGasLimit: bigint;       // 调用 Gas 限制
  verificationGasLimit: bigint; // 验证 Gas 限制
  preVerificationGas: bigint;  // 预验证 Gas
  maxFeePerGas: bigint;       // 最大 Gas 价格
  maxPriorityFeePerGas: bigint; // 最大优先费用
  paymasterAndData: string;    // Paymaster 数据
  signature: string;           // 签名
}
```

---

## 5. 数据流设计

### 5.1 路径A：极简体验创建流程

```
用户选择路径A
  ↓
生成智能账户密钥对（本地）
  ↓
加密存储私钥
  ↓
预测智能合约账户地址
  ↓
选择赞助商（从列表或邀请码）
  ↓
获取存储提供者（赞助商指定或默认IPFS）
  ↓
创建申请详情并上传到存储
  ↓
在链上注册索引（存储标识符+存储类型）
  ↓
保存账户信息（状态：pending）
  ↓
轮询申请状态
  ↓
赞助商审核通过
  ↓
赞助商代付Gas创建账户
  ↓
更新账户状态（deployed）
  ↓
用户收到通知，进入钱包主界面
```

### 5.2 路径B：标准模式创建流程

```
用户选择路径B
  ↓
EOA账户设置（创建/导入）
  ↓
生成智能账户密钥对
  ↓
选择Gas支付方式
  ├─→ 自付Gas：使用EOA直接部署
  │     ↓
  │   创建账户（状态：deployed）
  │     ↓
  │   进入钱包主界面
  │
  └─→ 申请赞助：类似路径A流程
        ↓
      创建申请（状态：pending）
        ↓
      等待审核...
```

### 5.3 路径C：成为赞助商流程

```
用户选择路径C
  ↓
设置赞助商资料
  ↓
配置Gas支付EOA账户
  ↓
转入初始Gas资金
  ↓
设置审核规则和渠道
  ↓
完成链上注册
  ↓
进入赞助商仪表板
  ↓
开始审核申请
  ↓
代付Gas创建账户
```

### 5.4 交易发送流程（统一）

```
用户构造交易（目标地址、数据）
  ↓
TransactionRelayer.sendTransaction()
  ↓
获取账户 nonce（EntryPoint.getNonce）
  ↓
构造 callData（Kernel.execute）
  ↓
估算 Gas（Bundler.estimateUserOperationGas）
  ↓
构造 UserOperation
  ↓
签名 UserOperation（EIP-191）
  ↓
发送到 Bundler（Bundler.sendUserOperation）
  ↓
返回交易哈希
  ↘︎ 降级分支：Bundler 不可用 → 本地估算 + RPC 直发，提示需自付 Gas
```

### 5.5 存储数据流（支持可插拔存储）

#### 5.5.1 用户提交申请（路径A）

```
用户创建申请详情
  ↓
获取存储提供者（赞助商指定或默认IPFS）
  ↓
上传申请详情到存储（StorageProvider.add）
  ↓
获取存储标识符（CID/URI）
  ↓
在链上注册索引（ApplicationRegistry.register）
  ├─ 存储标识符
  ├─ 存储类型
  └─ 申请状态
  ↓
本地缓存申请信息
  ↓
轮询申请状态
```

#### 5.5.2 赞助商审核申请

```
从链上获取申请索引
  ├─ 存储标识符
  └─ 存储类型
  ↓
根据存储类型获取存储提供者
  ↓
从存储获取申请详情（StorageProvider.get）
  ↓
创建审核记录
  ↓
使用相同存储提供者上传审核记录
  ↓
更新链上状态（包含审核记录存储标识符）
  ↓
如果批准，部署账户
```

#### 5.5.3 用户查询申请状态

```
从本地缓存检查
  ↓（缓存未命中或过期）
从链上获取最新状态
  ├─ 存储标识符
  └─ 存储类型
  ↓
根据存储类型获取存储提供者
  ↓
从存储获取申请详情
  ↓
如果有审核记录，获取审核详情
  ↓
更新本地缓存
```

---

## 6. 数据结构设计

### 6.1 AccountInfo（扩展）

```typescript
interface AccountInfo {
  address: string;                 // 智能合约账户地址
  chainId: number;                  // 链 ID
  owner: string;                   // 签名者地址（智能账户控制密钥）
  eoaAddress?: string;             // EOA地址（路径B和C）
  userType: UserType;              // 用户类型
  creationPath: AccountCreationPath; // 创建路径
  status: AccountStatus;           // 账户状态
  createdAt: number;                // 创建时间戳
  deployedAt?: number;              // 部署时间戳（可选）
  sponsorId?: string;               // 赞助商ID（路径A）
  sponsorAddress?: string;          // 赞助商地址（路径A）
}
```

### 6.2 Sponsor（新增）

```typescript
interface Sponsor {
  id: string;
  address: Address;
  name: string;
  description?: string;
  approvalRate: number;
  avgWaitTime: number;
  totalSponsored: number;
  availableBalance: bigint;
  rules?: SponsorRules;
}
```

### 6.3 Application（新增）

```typescript
interface Application {
  id: string;
  accountAddress: Address;
  ownerAddress: Address;
  eoaAddress?: Address;  // 路径B可能有
  sponsorId: string;
  chainId: number;
  status: 'pending' | 'approved' | 'rejected' | 'deployed';
  createdAt: number;
  reviewedAt?: number;
  deployedAt?: number;
  inviteCode?: string;   // 邀请码（如果有）
}
```

---

## 7. 错误处理设计

### 7.1 错误分类（扩展）

1. **网络错误**: RPC 调用失败、Bundler 不可用
2. **合约错误**: 账户不存在、Gas 不足、签名验证失败
3. **用户错误**: 密码错误、地址格式错误
4. **系统错误**: 存储失败、加密失败
5. **赞助商错误**（新增）: 赞助商不可用、申请被拒绝、审核超时

### 7.2 错误处理策略（扩展）

- **网络错误**: 自动重试、故障转移
- **合约错误**: 返回详细错误信息给用户
- **用户错误**: 友好的错误提示
- **系统错误**: 记录日志，通知用户
- **赞助商错误**（新增）: 提供重新选择赞助商、取消申请等选项

### 7.3 错误码定义（扩展）

```typescript
enum ErrorCode {
  NETWORK_ERROR = 'NETWORK_ERROR',
  CONTRACT_ERROR = 'CONTRACT_ERROR',
  AUTH_ERROR = 'AUTH_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  STORAGE_ERROR = 'STORAGE_ERROR',
  BUNDLER_UNAVAILABLE = 'BUNDLER_UNAVAILABLE',
  SPONSOR_UNAVAILABLE = 'SPONSOR_UNAVAILABLE',      // 新增
  APPLICATION_REJECTED = 'APPLICATION_REJECTED',    // 新增
  APPLICATION_TIMEOUT = 'APPLICATION_TIMEOUT',      // 新增
}
```

---

## 8. 安全设计

### 8.1 密钥管理（扩展）

- **自动生成密钥**：路径A和路径B自动生成智能账户密钥，用户无需提供EOA私钥
- 私钥仅存储在本地（加密存储）
- 使用 AES-GCM 加密（256 位密钥）
- PBKDF2 密钥派生（100,000 次迭代）
- 每个数据项使用独立的 salt
- 密码修改需触发全量重加密，失败时需保留旧密钥以支持回滚

### 8.2 赞助商安全（新增）

- **资金隔离**：赞助商Gas账户与个人资产分离
- **审核规则**：可设置每日限额、单账户最大Gas等规则
- **异常检测**：检测可疑申请行为
- **多层风控**：防止滥用和攻击

### 8.3 会话安全

- 会话有效期 30 分钟
- 5 分钟无活动自动锁定
- 会话数据加密存储
- 登出时清除所有敏感数据
- PWA 前后台切换时应立即锁定或提示用户确认

### 8.4 交易安全

- UserOperation 使用 EIP-191 标准签名
- 签名前验证所有参数
- 显示交易预览供用户确认
- 支持交易取消
- 在多 Bundler 失败后切换 RPC 时，需重新计算 userOpHash 防止签名重放

### 8.5 存储安全（新增）

- **存储标识符验证**：每个存储提供者必须实现`isValid()`方法，防止恶意标识符注入
- **链上验证**：合约验证存储类型和标识符格式，确保数据完整性
- **数据完整性**：IPFS内容寻址确保数据不可篡改，链上索引确保状态不可篡改
- **数据隐私**：敏感数据（如ownerAddress）可以加密后存储
- **可用性保障**：使用Pin服务确保数据持久化，多个Pin节点备份
- **存储提供者验证**：防止恶意存储提供者注入，验证自定义存储提供者的合法性

---

## 9. 性能优化设计

### 9.1 代码优化

- 路由级别的代码分割
- 组件懒加载
- Tree Shaking
- 资源压缩

### 9.2 运行时优化

- 使用 React.memo 减少重渲染
- 使用 useMemo 和 useCallback 缓存计算结果
- 虚拟滚动（长列表）
- 防抖和节流（用户输入）

### 9.3 网络优化

- RPC 请求缓存
- 批量请求合并
- 请求重试机制
- 故障转移
- 离线/弱网降级：切换为只读模式并缓存最近区块高度

### 9.4 申请状态轮询优化（新增）

- 使用 WebSocket（如果可用）替代轮询
- 指数退避策略
- 前台优先：标签页隐藏时暂停轮询
- 状态缓存：避免重复查询

### 9.5 存储性能优化（新增）

- **本地缓存**：缓存存储数据，减少IPFS请求
- **批量获取**：如果存储提供者支持，使用批量获取减少请求次数
- **缓存策略**：TTL缓存，定期刷新
- **存储提供者选择**：根据延迟和可用性选择最优提供者

---

## 总结

本文档详细描述了 AnDaoWallet HTML5 版本的核心模块设计，特别是**三路径统一架构**和**可插拔存储架构**的详细实现。各模块遵循模块化设计原则，接口清晰，便于维护和扩展。

### 关键设计亮点

1. **三路径统一架构**：同一应用，三种入口，满足不同用户需求
2. **自动生成密钥**：路径A和路径B自动生成智能账户密钥，用户无需提供EOA私钥
3. **赞助商机制**：通过去中心化的赞助商网络，让Web3新手零门槛进入
4. **可插拔存储架构**：钱包使用通用IPFS存储，赞助商可选择自己的存储方案
5. **路径可转换**：用户可在后续使用中切换路径
6. **统一体验**：所有路径最终汇合到统一主界面

### 下一步工作

1. ✅ 完善三路径创建流程实现
2. ⚠️ 实现存储接口和默认IPFS存储提供者
3. ⚠️ 实现 SponsorService（赞助商服务，集成存储）
4. ⚠️ 实现申请审核系统（赞助商端，使用存储）
5. ⚠️ 实现路径转换功能
6. ⚠️ 部署ApplicationRegistry合约（支持存储类型）
7. ⚠️ 完善 Paymaster 集成与 Bundler 故障转移降级路径
8. ⚠️ 补齐社交恢复与延迟/条件交易插件实现
9. ⚠️ 完善自动锁定与密钥轮换策略，覆盖 PWA 前后台场景
10. ⚠️ 完善测试覆盖（离线/弱网、Bundler 不可用、密码轮换、赞助商机制、存储系统）

---

## 附录A：实现状态对照（基于代码审查）

本附录将“系统详细设计”中的关键模块与实际代码实现状态对齐，避免“文档写待实现但代码已实现/反之”的漂移。

### A.1 与设计一致的已实现模块 ✅

- **三路径账户创建页面**：`CreateAccountPathAPage` / `CreateAccountPathBPage` / `CreateAccountPathCPage` 已实现并带有较完整注释。
- **赞助商服务核心能力**：`SponsorService` 已实现注册、创建申请、审核、代付部署等关键流程（含部分链上交互与本地落库）。
- **可插拔存储系统**：已实现 `IStorageProvider`、默认 IPFS Provider、`StorageProviderManager` 以及相关导出与调用路径。
- **链上索引客户端**：`ApplicationRegistryClient` 已实现用于读取/更新链上索引状态（与存储标识符/状态同步配合）。

### A.2 仍需补齐的模块/页面 ⚠️

- **助记词导入**：设计支持，但实现仍存在 TODO；需要引入/集成 `bip39` 并补齐助记词校验、派生与错误提示。
- **赞助商仪表板页面**：详细设计中描述的 Sponsor Dashboard 尚未落地为独立页面（当前可能以导航占位替代）。

### A.3 文档维护规则（强约束）

- 当代码实现状态变化时：
  - 同步更新本附录 A 的 ✅/⚠️ 列表
  - 同步更新主文档中出现的 “待实现/已实现” 标记，确保系统文档始终是事实来源

---

## 附录B：两阶段提交（Two-Phase Commit）加密存储设计

本附录补充“两阶段提交”在前端侧的**加密存储实现细节**，用于解释：为什么承诺阶段可以不泄露原始数据、揭示阶段如何可靠解密并发送到合约。

### B.1 功能概述

- **承诺阶段（Commit）**：对原始数据生成承诺哈希并上链；同时将原始数据在本地**加密保存**（仅保存密文）。
- **揭示阶段（Reveal）**：满足合约条件后，从本地密文**解密还原**原始数据并调用合约 reveal。

### B.2 三特征密钥系统（StableThreeFeatureKey）

加密密钥由三个稳定特征组成：

1. **用户 ID**（`userId`）
   - 用户注册/初始化时设置
   - 存储于本地（例如 localStorage）
2. **程序硬编码**（`appCode`）
   - 固定字符串常量（版本内保持不变）
3. **操作系统特征**（`osFeature`）
   - 由 `navigator.platform` + `navigator.userAgent` 提取 OS 大类（WINDOWS / MACOS / LINUX / IOS / ANDROID）
   - 不包含版本号，减少系统升级导致无法解密的风险

密钥生成流程（示意）：

```
userId + appCode + osFeature + 固定盐值
  ↓
SHA-256
  ↓
取前 32 字节作为 AES-256-GCM 密钥
```

### B.3 加密算法与安全性

- **AES-256-GCM**：每次加密使用随机 IV，提供机密性 + 完整性校验
- **最小暴露原则**：链上仅存承诺哈希；本地仅存密文；外部服务不接触明文

### B.4 典型调用流程（伪代码）

初始化密钥系统（设置 userId）：

```typescript
import { stableThreeFeatureKey } from '@/services/StableThreeFeatureKey';

await stableThreeFeatureKey.initialize('user123');
```

承诺阶段（加密保存原始数据）：

```typescript
const originalData = 'my secret vote data';
const commitmentHash = await twoPhaseCommitService.generateCommitmentHash(originalData);
const commitTxHash = await transactionRelayer.sendTransaction(/* commit */);

// createTask 内部会加密保存 originalData
await twoPhaseCommitService.createTask(
  chainId,
  contractAddress,
  commitmentHash,
  commitTxHash,
  originalData,
  accountAddress
);
```

揭示阶段（自动解密并发送）：

```typescript
// 不提供 overrideData 时，从任务中解密恢复 originalData
await twoPhaseCommitService.reveal(taskId, signerPrivateKey);
```

---

## 附录C：延迟/条件交易插件接口补充（接口完善说明）

本附录补充插件接口的关键签名与交互点，避免“文档接口与代码实现不一致”。

### C.1 DelayedTransactionPlugin（延迟交易）

#### scheduleTransaction

- **补充点**：增加 `signerPrivateKey` 以发送调度交易；统一 transactionHash 计算；完善错误处理与状态管理。

```typescript
async scheduleTransaction(
  accountAddress: Address,
  chainId: number,
  config: DelayedTransactionConfig,
  signerPrivateKey: `0x${string}`
): Promise<DelayedTransaction>
```

合约侧关键方法（示意）：

```solidity
function schedule(
  bytes32 transactionHash,
  address target,
  uint256 value,
  bytes calldata data,
  uint256 delay
) external
```

#### cancelTransaction

```typescript
async cancelTransaction(
  transactionId: string,
  accountAddress: Address,
  chainId: number,
  signerPrivateKey: `0x${string}`
): Promise<string>
```

#### executeTransaction

```typescript
async executeTransaction(
  transaction: DelayedTransaction,
  signerPrivateKey: `0x${string}`
): Promise<string>
```

#### checkAndExecuteDueTransactions

```typescript
async checkAndExecuteDueTransactions(
  signerPrivateKey: `0x${string}`
): Promise<number>
```

### C.2 ConditionalTransactionPlugin（条件交易）

- **补充点**：完善 `CONTRACT_STATE` 条件检查，支持自定义 ABI + 参数，支持 view 调用与状态读取。

条件参数示意：

```typescript
{
  address: Address,
  functionName: string,
  abi: any[],
  args?: any[]
}
```

---

## 附录D：账户抽象（AA）术语与组件速查

为便于阅读本系统文档，这里对 AA 常用概念做一个快速对齐：

- **UserOperation**：ERC-4337 的用户操作结构体（替代传统交易），由 Bundler 打包上链
- **EntryPoint**：ERC-4337 核心合约，负责 validate/execute userOp 并处理 paymaster
- **Bundler**：链下服务，接收 userOp、估算 gas、提交到 EntryPoint
- **Paymaster**：可选组件，为 userOp 提供 gas 代付策略
- **Kernel**：高效、模块化的智能合约账户实现，支持插件/验证器扩展（ERC-7579）

**文档版本历史**:
- v2.0 (2025-01-13): 引入三路径统一架构设计，扩展账户信息结构，新增赞助商服务设计
- v1.0 (2024): 初始版本
