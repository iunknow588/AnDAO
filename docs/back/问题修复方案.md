# AnDaoWallet è®¾è®¡é—®é¢˜ä¿®å¤æ–¹æ¡ˆ

## å¿«é€Ÿå‚è€ƒ

åŸºäºã€Šè®¾è®¡é€»è¾‘é—®é¢˜åˆ†ææŠ¥å‘Šã€‹ï¼Œæœ¬æ–‡æ¡£æä¾›å…·ä½“çš„ä¿®å¤å®æ–½æ­¥éª¤å’Œä»£ç ç¤ºä¾‹ã€‚

---

## ä¿®å¤ä¼˜å…ˆçº§

### ğŸ”´ P0 - ç´§æ€¥ä¿®å¤ï¼ˆå½±å“æ ¸å¿ƒåŠŸèƒ½ï¼‰

#### 1. è´¦æˆ·çŠ¶æ€ç®¡ç†é—®é¢˜ä¿®å¤

**é—®é¢˜**: è´¦æˆ·çŠ¶æ€æ··æ·†ï¼Œæœªéƒ¨ç½²è´¦æˆ·è¢«æ ‡è®°ä¸ºå·²åˆ›å»º

**ä¿®å¤æ­¥éª¤**:

1. **æ›´æ–° AccountInfo æ¥å£** (`src/types/index.ts`):

```typescript
export interface AccountInfo {
  address: string;
  chainId: number;
  owner: string;
  createdAt: number;
  status: 'predicted' | 'deployed'; // æ–°å¢
  deployedAt?: number; // å¯é€‰ï¼šéƒ¨ç½²æ—¶é—´æˆ³
}
```

2. **é‡æ„ AccountManager** (`src/services/AccountManager.ts`):

```typescript
// åˆ†ç¦»é¢„æµ‹å’Œéƒ¨ç½²æ–¹æ³•
async predictAccountAddress(owner: Address, chainId: number): Promise<Address> {
  // ä»…é¢„æµ‹ï¼Œä¸ä¿å­˜
  const chainConfig = getChainConfigByChainId(chainId);
  if (!chainConfig || !chainConfig.kernelFactoryAddress) {
    throw new Error(`Chain config not found for chainId: ${chainId}`);
  }

  const initData = await this.buildInitData(owner, chainId);
  const salt = await this.generateSalt(owner, chainId);
  
  const { predictAccountAddress } = await import('@/utils/kernel');
  return predictAccountAddress(
    chainConfig.kernelFactoryAddress as Address,
    initData,
    salt,
    chainConfig.rpcUrl
  );
}

// éƒ¨ç½²è´¦æˆ·ï¼ˆå¿…éœ€ç§é’¥ï¼‰
async createAndDeployAccount(
  owner: Address, 
  chainId: number, 
  signerPrivateKey: `0x${string}`
): Promise<Address> {
  // æ£€æŸ¥æ˜¯å¦å·²éƒ¨ç½²
  const predictedAddress = await this.predictAccountAddress(owner, chainId);
  const existing = await this.getAccount(owner, chainId);
  
  if (existing?.status === 'deployed') {
    const deployed = await this.accountExists(predictedAddress, chainId);
    if (deployed) {
      return predictedAddress;
    }
  }

  // éƒ¨ç½²è´¦æˆ·
  const chainConfig = getChainConfigByChainId(chainId);
  if (!chainConfig?.kernelFactoryAddress) {
    throw new Error(`Kernel Factory address not configured for chain: ${chainId}`);
  }

  const initData = await this.buildInitData(owner, chainId);
  const salt = await this.generateSalt(owner, chainId);
  
  const { createAccount } = await import('@/utils/kernel');
  const accountAddress = await createAccount(
    chainConfig.kernelFactoryAddress as Address,
    initData,
    salt,
    chainConfig.rpcUrl,
    signerPrivateKey
  );

  // ä¿å­˜å·²éƒ¨ç½²è´¦æˆ·ä¿¡æ¯
  const accountInfo: AccountInfo = {
    address: accountAddress,
    chainId,
    owner,
    createdAt: Date.now(),
    status: 'deployed',
    deployedAt: Date.now(),
  };

  this.accounts.set(`${chainId}:${accountAddress}`, accountInfo);
  await this.saveAccounts();

  return accountAddress;
}

// ä¿æŒå‘åå…¼å®¹çš„ä¾¿æ·æ–¹æ³•
async createAccount(
  owner: Address, 
  chainId: number, 
  signerPrivateKey: `0x${string}`
): Promise<Address> {
  return this.createAndDeployAccount(owner, chainId, signerPrivateKey);
}

// æ›´æ–° getAccountAddress æ–¹æ³•
async getAccountAddress(owner: Address, chainId: number): Promise<Address | null> {
  // å…ˆæŸ¥æ‰¾å·²ä¿å­˜çš„è´¦æˆ·
  const account = await this.getAccount(owner, chainId);
  if (account) {
    return account.address as Address;
  }
  
  // å¦‚æœæœªæ‰¾åˆ°ï¼Œè¿”å›é¢„æµ‹åœ°å€ï¼ˆä½†ä¸ä¿å­˜ï¼‰
  return await this.predictAccountAddress(owner, chainId);
}
```

3. **æ›´æ–° AccountStore** (`src/stores/AccountStore.ts`):

```typescript
async createAccount(owner: string, chainId: number, signerPrivateKey: string): Promise<void> {
  // ç°åœ¨éœ€è¦æä¾›ç§é’¥
  const address = await accountManager.createAndDeployAccount(
    owner as `0x${string}`, 
    chainId,
    signerPrivateKey as `0x${string}`
  );
  // ... æ›´æ–°çŠ¶æ€ ...
}
```

#### 2. UserOperation ç­¾åé€»è¾‘ä¿®å¤

**é—®é¢˜**: ç­¾åé€»è¾‘ä¸ç¬¦åˆ ERC-4337 å’Œ Kernel è§„èŒƒ

**ä¿®å¤æ­¥éª¤**:

1. **æ›´æ–° TransactionRelayer** (`src/services/TransactionRelayer.ts`):

```typescript
/**
 * ç­¾å UserOperation
 * 
 * ç­¾åæµç¨‹ï¼ˆç¬¦åˆ ERC-4337 å’Œ Kernel è§„èŒƒï¼‰ï¼š
 * 1. è®¡ç®— UserOperation å“ˆå¸Œï¼ˆä½¿ç”¨ EIP-712 æ–¹å¼ï¼‰
 * 2. ä½¿ç”¨ owner ç§é’¥ç­¾åå“ˆå¸Œï¼ˆEIP-191 æ ‡å‡†ï¼‰
 * 3. ç­¾åä¾› MultiChainValidator éªŒè¯ä½¿ç”¨
 */
private async signUserOperation(
  userOp: UserOperation,
  chainId: number,
  ownerPrivateKey: `0x${string}` // æ˜ç¡®è¿™æ˜¯ owner çš„ç§é’¥
): Promise<UserOperation> {
  const chainConfig = getChainConfigByChainId(chainId);
  if (!chainConfig || !chainConfig.entryPointAddress) {
    throw new Error(`Chain config or EntryPoint address not found for chainId: ${chainId}`);
  }

  // 1. è®¡ç®— UserOperation å“ˆå¸Œï¼ˆEIP-712ï¼‰
  const { getUserOpHash } = await import('@/utils/eip712');
  const userOpHash = getUserOpHash(
    userOp,
    chainConfig.entryPointAddress as `0x${string}`,
    chainId
  );

  // 2. ä½¿ç”¨ owner ç§é’¥ç­¾åå“ˆå¸Œï¼ˆEIP-191ï¼‰
  const { signMessage } = await import('@/utils/eip712');
  const signature = await signMessage(userOpHash, ownerPrivateKey);

  return {
    ...userOp,
    signature: signature,
  };
}

// æ›´æ–° sendTransaction æ–¹æ³•ç­¾å
async sendTransaction(
  accountAddress: Address,
  chainId: number,
  target: Address,
  data: string,
  ownerPrivateKey: `0x${string}` // å¿…éœ€å‚æ•°
): Promise<Hash> {
  // ... å®ç° ...
  const signedUserOp = await this.signUserOperation(userOp, chainId, ownerPrivateKey);
  // ... å‘é€ ...
}
```

2. **æ›´æ–°æ–‡æ¡£æ³¨é‡Š** (`src/services/TransactionRelayer.ts`):

```typescript
/**
 * å‘é€å•ç¬”äº¤æ˜“
 * 
 * @param accountAddress æ™ºèƒ½åˆçº¦è´¦æˆ·åœ°å€
 * @param chainId é“¾ ID
 * @param target ç›®æ ‡åœ°å€
 * @param data è°ƒç”¨æ•°æ®
 * @param ownerPrivateKey owner çš„ç§é’¥ï¼ˆç”¨äºç­¾å UserOperationï¼Œä¾› Validator éªŒè¯ï¼‰
 *                       æ³¨æ„ï¼šè¿™æ˜¯è´¦æˆ· owner çš„ç§é’¥ï¼Œä¸æ˜¯è´¦æˆ·åˆçº¦çš„ç§é’¥
 */
```

### ğŸŸ¡ P1 - é«˜ä¼˜å…ˆçº§ï¼ˆå½±å“ç”¨æˆ·ä½“éªŒï¼‰

#### 3. Nonce è·å–å¤±è´¥å¤„ç†

**ä¿®å¤** (`src/services/TransactionRelayer.ts`):

```typescript
private async getAccountNonce(accountAddress: Address, chainId: number): Promise<bigint> {
  const chainConfig = getChainConfigByChainId(chainId);
  if (!chainConfig || !chainConfig.entryPointAddress) {
    throw new Error(`EntryPoint address not configured for chain: ${chainId}`);
  }

  // æ£€æŸ¥è´¦æˆ·æ˜¯å¦å·²éƒ¨ç½²
  const accountManager = await import('@/services/AccountManager').then(m => m.accountManager);
  const accountInfo = await accountManager.getAccountByAddress?.(accountAddress, chainId);
  
  if (!accountInfo || accountInfo.status !== 'deployed') {
    // æœªéƒ¨ç½²è´¦æˆ·ï¼Œnonce ä¸º 0
    return BigInt(0);
  }

  try {
    const { getAccountNonce } = await import('@/utils/kernel');
    return await getAccountNonce(
      chainConfig.entryPointAddress as Address,
      accountAddress,
      chainConfig.rpcUrl
    );
  } catch (error) {
    // å¦‚æœè·å–å¤±è´¥ï¼Œå¯èƒ½æ˜¯è´¦æˆ·æœªéƒ¨ç½²ï¼Œè¿”å› 0
    console.warn('Failed to get nonce, assuming 0:', error);
    return BigInt(0);
  }
}
```

**æ·»åŠ  AccountManager.getAccountByAddress æ–¹æ³•**:

```typescript
async getAccountByAddress(address: Address, chainId: number): Promise<AccountInfo | null> {
  const key = `${chainId}:${address.toLowerCase()}`;
  return this.accounts.get(key) || null;
}
```

#### 4. Bundler æ•…éšœè½¬ç§»é€»è¾‘ä¿®å¤

**ä¿®å¤** (`src/services/BundlerClient.ts`):

```typescript
async sendUserOperation(userOp: UserOperation, chainId?: number): Promise<Hash> {
  if (this.bundlers.length === 0) {
    throw new Error('No bundler configured');
  }

  const entryPointAddress = this.getEntryPointAddress(chainId);

  // æ„å»ºå°è¯•åˆ—è¡¨ï¼šä¼˜å…ˆä½¿ç”¨ currentBundler
  const bundlersToTry: BundlerConfig[] = [];
  if (this.currentBundler) {
    bundlersToTry.push(this.currentBundler);
  }
  // æ·»åŠ å…¶ä»– bundlersï¼ˆæ’é™¤å·²æ·»åŠ çš„ currentBundlerï¼‰
  for (const bundler of this.bundlers) {
    if (bundler.url !== this.currentBundler?.url) {
      bundlersToTry.push(bundler);
    }
  }

  // å¦‚æœ currentBundler æœªè®¾ç½®ï¼Œä½¿ç”¨åˆ—è¡¨é¡ºåº
  if (bundlersToTry.length === 0) {
    bundlersToTry.push(...this.bundlers);
  }

  // å°è¯•å‘é€
  let lastError: Error | null = null;
  for (const bundler of bundlersToTry) {
    try {
      const hash = await this.sendToBundler(userOp, bundler.url, entryPointAddress);
      // æˆåŠŸæ—¶æ›´æ–° currentBundler
      this.currentBundler = bundler;
      return hash;
    } catch (error) {
      console.warn(`Bundler ${bundler.name} failed, trying next...`, error);
      lastError = error as Error;
      continue;
    }
  }

  throw new Error(`All bundlers failed. Last error: ${lastError?.message || 'Unknown error'}`);
}
```

### ğŸŸ¢ P2 - ä¸­ä¼˜å…ˆçº§ï¼ˆä¼˜åŒ–æ”¹è¿›ï¼‰

#### 5. Gas ä¼°ç®—é™çº§æ–¹æ¡ˆæ”¹è¿›

**ä¿®å¤** (`src/services/TransactionRelayer.ts`):

```typescript
private async estimateGas(
  accountAddress: Address,
  chainId: number,
  callData: string,
  userOp: Partial<UserOperation>,
  bundlerUrl: string
): Promise<{
  callGasLimit: bigint;
  verificationGasLimit: bigint;
  preVerificationGas: bigint;
}> {
  // ... å°è¯• Bundler ä¼°ç®— ...

  // é™çº§æ–¹æ¡ˆï¼šæ™ºèƒ½ä¼°ç®—
  console.warn('Gas estimation failed, using fallback estimation');
  
  const chainConfig = getChainConfigByChainId(chainId);
  if (!chainConfig) {
    throw new Error(`Chain config not found for chainId: ${chainId}`);
  }

  // ä½¿ç”¨é“¾é…ç½®çš„é»˜è®¤å€¼ï¼ˆå¦‚æœé…ç½®äº†ï¼‰
  if (chainConfig.defaultGasLimits) {
    return chainConfig.defaultGasLimits;
  }

  // åŸºäº callData å¤§å°ä¼°ç®—
  const callDataSize = (callData.length - 2) / 2; // å»é™¤ 0x å‰ç¼€
  const baseCallGas = BigInt(21000); // åŸºç¡€äº¤æ˜“ Gas
  const dataGas = BigInt(callDataSize) * BigInt(16); // æ¯å­—èŠ‚ 16 gas
  const callGasLimit = baseCallGas + dataGas + BigInt(50000); // é¢å¤–ç¼“å†²

  // æ ¹æ®é“¾ç±»å‹ä¼°ç®— verificationGasLimit
  const baseVerificationGas = chainConfig.chainId === 5000 // Mantle
    ? BigInt(100000)
    : BigInt(150000);

  const preVerificationGas = BigInt(50000);

  return {
    callGasLimit,
    verificationGasLimit: baseVerificationGas,
    preVerificationGas,
  };
}
```

**æ›´æ–° ChainConfig** (`src/types/index.ts`):

```typescript
export interface ChainConfig {
  // ... ç°æœ‰å­—æ®µ ...
  defaultGasLimits?: {
    callGasLimit: bigint;
    verificationGasLimit: bigint;
    preVerificationGas: bigint;
  };
}
```

#### 6. å¯†ç éªŒè¯é€»è¾‘ä¿®å¤

**ä¿®å¤** (`src/services/AuthService.ts`):

```typescript
/**
 * æ£€æŸ¥æ˜¯å¦æ˜¯é¦–æ¬¡ç™»å½•
 */
async isFirstLogin(userId: string = 'default'): Promise<boolean> {
  const testKey = `test_${userId}`;
  try {
    // å°è¯•ä»å­˜å‚¨ä¸­è·å–åŠ å¯†æ•°æ®çš„å…ƒæ•°æ®ï¼ˆä¸ä¾èµ–å¯†ç ï¼‰
    const metaKey = `meta_${testKey}`;
    const meta = await storageAdapter.get(metaKey);
    return meta === null;
  } catch {
    return true;
  }
}

/**
 * é¦–æ¬¡ç™»å½•ï¼ˆåˆ›å»ºå¯†ç ï¼‰
 */
async firstLogin(password: string, userId: string = 'default'): Promise<boolean> {
  if (!(await this.isFirstLogin(userId))) {
    throw new Error('Not first login, use login() instead');
  }
  
  const testKey = `test_${userId}`;
  await securityVault.setItem(testKey, { verified: true, createdAt: Date.now() }, password);
  
  // æ ‡è®°å·²åˆå§‹åŒ–
  const metaKey = `meta_${testKey}`;
  await storageAdapter.set(metaKey, { initialized: true });
  
  // åˆ›å»ºä¼šè¯
  return this.createSession(userId);
}

/**
 * ç™»å½•/è§£é”ï¼ˆéªŒè¯å¯†ç ï¼‰
 */
async login(password: string, userId: string = 'default'): Promise<boolean> {
  if (await this.isFirstLogin(userId)) {
    throw new Error('First login required, use firstLogin() instead');
  }
  
  try {
    const testKey = `test_${userId}`;
    const testData = await securityVault.getItem(testKey, password);
    
    if (testData === null) {
      // å¯†ç é”™è¯¯ï¼ˆè§£å¯†å¤±è´¥ï¼‰
      return false;
    }
    
    if (!testData.verified) {
      console.warn('Test data verification failed');
      return false;
    }
    
    // åˆ›å»ºä¼šè¯
    return this.createSession(userId);
  } catch (error) {
    console.error('Login failed:', error);
    return false;
  }
}

/**
 * åˆ›å»ºä¼šè¯ï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰
 */
private async createSession(userId: string): Promise<boolean> {
  this.session = {
    userId,
    createdAt: Date.now(),
    expiresAt: Date.now() + this.SESSION_DURATION,
  };

  await storageAdapter.set(StorageKey.SESSION, this.session);
  this.startAutoLock();
  this.setupActivityListeners();
  return true;
}
```

---

## æµ‹è¯•è®¡åˆ’

### å•å…ƒæµ‹è¯•

1. **AccountManager æµ‹è¯•**:
   - æµ‹è¯• `predictAccountAddress` ä¸ä¿å­˜è´¦æˆ·
   - æµ‹è¯• `createAndDeployAccount` ä¿å­˜å·²éƒ¨ç½²è´¦æˆ·
   - æµ‹è¯•è´¦æˆ·çŠ¶æ€ç®¡ç†

2. **TransactionRelayer æµ‹è¯•**:
   - æµ‹è¯•ç­¾åé€»è¾‘
   - æµ‹è¯• Nonce è·å–ï¼ˆå·²éƒ¨ç½²/æœªéƒ¨ç½²ï¼‰
   - æµ‹è¯• Gas ä¼°ç®—é™çº§

3. **BundlerClient æµ‹è¯•**:
   - æµ‹è¯•æ•…éšœè½¬ç§»é€»è¾‘
   - æµ‹è¯• currentBundler ä¼˜å…ˆçº§

4. **AuthService æµ‹è¯•**:
   - æµ‹è¯•é¦–æ¬¡ç™»å½•æµç¨‹
   - æµ‹è¯•å¯†ç éªŒè¯

### é›†æˆæµ‹è¯•

1. è´¦æˆ·åˆ›å»ºåˆ°éƒ¨ç½²çš„å®Œæ•´æµç¨‹
2. äº¤æ˜“å‘é€æµç¨‹ï¼ˆåŒ…æ‹¬ç­¾åï¼‰
3. Bundler æ•…éšœè½¬ç§»åœºæ™¯

---

## è¿ç§»æŒ‡å—

### æ•°æ®è¿ç§»

å¯¹äºå·²å­˜åœ¨çš„è´¦æˆ·æ•°æ®ï¼Œéœ€è¦è¿›è¡Œè¿ç§»ï¼š

```typescript
// è¿ç§»è„šæœ¬
async function migrateAccountData() {
  const accounts = await storageAdapter.get<AccountInfo[]>(StorageKey.ACCOUNTS);
  if (!accounts) return;

  const migratedAccounts = accounts.map(account => {
    // æ£€æŸ¥è´¦æˆ·æ˜¯å¦å·²éƒ¨ç½²
    // å¦‚æœ accountExists è¿”å› trueï¼Œåˆ™ status = 'deployed'
    // å¦åˆ™ status = 'predicted'
    return {
      ...account,
      status: 'deployed', // æˆ–æ ¹æ®å®é™…æƒ…å†µåˆ¤æ–­
    };
  });

  await storageAdapter.set(StorageKey.ACCOUNTS, migratedAccounts);
}
```

### API å˜æ›´

1. **AccountManager.createAccount**: 
   - `signerPrivateKey` ä»å¯é€‰å˜ä¸ºå¿…éœ€
   - è¿”å›å€¼åŒ…å« `status` å­—æ®µ

2. **TransactionRelayer.sendTransaction**:
   - `signerPrivateKey` ä»å¯é€‰å˜ä¸ºå¿…éœ€
   - å‚æ•°é‡å‘½åä¸º `ownerPrivateKey`

3. **AuthService.login**:
   - éœ€è¦å…ˆè°ƒç”¨ `isFirstLogin` åˆ¤æ–­
   - é¦–æ¬¡ç™»å½•ä½¿ç”¨ `firstLogin`

---

## å®æ–½æ—¶é—´è¡¨

1. **Week 1**: P0 é—®é¢˜ä¿®å¤ï¼ˆè´¦æˆ·çŠ¶æ€ç®¡ç†ã€ç­¾åé€»è¾‘ï¼‰
2. **Week 2**: P1 é—®é¢˜ä¿®å¤ï¼ˆNonceã€Bundler æ•…éšœè½¬ç§»ï¼‰
3. **Week 3**: P2 é—®é¢˜ä¿®å¤ï¼ˆGas ä¼°ç®—ã€å¯†ç éªŒè¯ï¼‰
4. **Week 4**: æµ‹è¯•ã€æ–‡æ¡£æ›´æ–°ã€ä»£ç å®¡æŸ¥

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2024å¹´
